# benthic_taxa_simulation
## Introduction
This repo provides code to simulate data derived from the Seattle Aquarium's remotely operated vehicle (ROV) kelp forest survey program (see [here](https://github.com/zhrandell/Seattle_Aquarium_ROV_development)). Specifically, we include code to simulate data derived from downward- and forward-facing cameras mounted on the ROV. Our purpose here is to provide simulated data to feed to a bull kelp habitat suitability model (linked [here](https://experience.arcgis.com/experience/b11daaa83ff045f1a9d88b2b926e1f75/page/About/)) that is being modified by our team to further advance bull kelp conservation and restoration.  

The downward-facing camera is used to characterize percent-coverage of aggregate taxa such as fleshy red algae, brown algae, and substrate type. Imagery are analyzed in CoralNet to generate metrics of percent-coverage. Here, our code simulates data derived from CoralNet, where our columns all sum to `col_sum = 50`, mirroring the x50 percent-coverage data points classified in every image. 

Imagery from the forward-facing camera is used to classify discrete and individually specific objects encountered by the ROV such as bull kelp stipes, kelp crabs, and fishes. Here, our code provides the means to simulate and append these data to the simulated percent-coverage data. 

Finally, we simulate these data in a manner that approximates our real-world ROV surveys from the Urban Kelp Research Project with the Port of Seattle. That is to say, our simulated benthic community data have the exact structure (in terms of the number of rows representing sites and transects) as our summer 2023 Urban Kelp ROV surveys. 

In terms of content, we include the following: 
* [code](https://github.com/zhrandell/Seattle_Aquarium_benthic_taxa_simulation/tree/main/code) contains _R_ scripts to combine and clean our real-world ROV telemetry files in preparation to append it to our simulated data ([`wrangle_metadata.R`](https://github.com/zhrandell/Seattle_Aquarium_benthic_taxa_simulation/blob/main/code/wrangle_metadata.R)), as well as code necessary to simulate percent-coverage and abundance data ([`simulate_taxa.R`](https://github.com/zhrandell/Seattle_Aquarium_benthic_taxa_simulation/blob/main/code/CoralNet_simulation.R)).
* [data_input](https://github.com/zhrandell/Seattle_Aquarium_benthic_taxa_simulation/tree/main/data_input) contains our Urban Kelp ROV telemetry files from summer 2023.
* [data_output](https://github.com/zhrandell/Seattle_Aquarium_benthic_taxa_simulation/tree/main/data_output) contains all derived files from our analyses, including the combined metadata.csv file we append to our simulated data.    


Below we lay out a brief overview of our code and how to implement it. 

## CoralNet percent-coverage simulation

Simulating CoralNet requires diligence to avoid simulated values that exceed `col_50 = 50`, the number of data points processed per each image. We achieve this in a two-step process. First, we simulate any given percent-cover category, e.g., red algae: 

```
i1 <- round(rgamma(total_n, shape = gamma_mu_S1, scale = 1), 0)
```
Here, `rgamma` randomly draws from a gamma distribution with `shape = gamma_mu_S1`, e.g., 5, and `scale = 1`. The `round()` functions ensure we have whole numbers (as our real-world CoralNet annotations always sum to a whole number such as 50 or 100. We expand this code slight to enable different `shape` parameters for different sites: 

```
i1 <- round(rgamma(total_n, shape = c(rep(gamma_mu_S1, rows[1,2]),
                                      rep(gamma_mu_S2, rows[2,2]), scale=1)), 0)
```
Here, `gamma_mu_S1` and `gamma_mu_S2` provide two different parameter values, and the `rgamma()` random draws are repeated `rep()` down rows with lengths defined by `rows[1,2`, and `rows[2,2]` a dataframe of site-specific row lengths that was generated by `wrangle_metadata.R` and can be found [here](https://github.com/zhrandell/Seattle_Aquarium_benthic_taxa_simulation/blob/main/data_output/nrows_site.csv). 

Next, because subsequent taxa simulated cannot exceed the values within `i1`, we run the following: 

```
b2 <- (col_sum - i1) 
```
creating a new vector that designates the upper bounds that subsequent values can take, with `col_sum = 50`, the number of data points we annotate in CoralNet. 

Now, for the next percent-cover category simulated (e.g., sugar kelp), we switch to a truncated normal distribution, as the "truncated" allows us to place a hard limit on the distribution, thereby ensure we do not simulate values greater than 50 (i.e., greater than `col_sum - i1`). Specifically: 

```
i2 <- round(rtruncnorm(total_n, a, b2, mean = c(rep(norm_mu_2_S1, rows[1,2]), 
                                                rep(norm_mu_2_S2, rows[2,2]),
                                                rep(norm_mu_2_S3, rows[3,2]),
                                                rep(norm_mu_2_S4, rows[4,2]), sd = i2_sd), 0)
```
we've added two additional ROV sites worth of simulations

